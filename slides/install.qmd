---
title: "Installing Julia and VS Code"
author: "Mattias Villani" 
editor: visual
---

# Installing Julia

The recommended way to install Julia is using a little tool called `juliaup` . Benefits of `juliaup` :

-   makes the install really easy

-   allows you to switch between different versions of Julia

-   notifies when a new version is available

Instructions on how to install juliaup are [here](https://julialang.org/install/). In short:

-   On **Mac/Linux**: run the following command in terminal:

    ```         
    curl -fsSL https://install.julialang.org | sh
    ```

-   On **Windows**, type this in the terminal to install from Windows store:

    ```         
    winget install --name Julia --id 9NJNWW8PVKMN -e -s msstore
    ```

::: callout-warning
## Avoid Linux repositories

It is not recommended to install Julia from repositories on Linux since the versions there can be rather old.
:::

::: callout-tip
## Uninstall juliaup

Juliaup can be uninstalled with the terminal command: `juliaup self uninstall`
:::

Julia can now be started by typing `julia` in the terminal (you may need to restart the shell/terminal so your system can find it). You should see something like:

![](figs/juliastart.png)

This what is known as the console in the R world. In Julia we tend to call it the **REPL** (Read-Evaluate-Print Loop). We will soon use VS Code as our main working environment (IDE, similar to RStudio, but much more general). But let's take a first dive in Julia directly in the REPL.

# A first try with Julia in the REPL

The REPL can be used to evaluate commands as in any interpreted language.

Old commands can be found quite nicely in the REPL:

-   arrow-up and arrow-down goes back in command history. Typing, for example, `myf` and then arrow-up cycles old commands that start with `myf`. Ctrl+r gives more advanced reverse-search.

-   past commands can be edited and re-used.

![](figs/navigateREPL.gif){width="500"}

The REPL has several prompt modes, for example:

-   **Julian mode**, which is the default seen above.

-   **Help mode**, activated by typing **?** at the prompt. The prompt changes to `help?>` and you can search for documentation about functions etc. Backspace takes you back to Julian mode.

-   **Shell mode**, activated by typing a semicolon **;**. The prompt changes to `shell>` and you can use the usual shell commands for navigating directories, copying files etc. (On Windows, type `powershell` or `cmd` at `shell>` to get access to the shell).

-   **Pkg mode**, activated by typing a right bracket **\]**. This opens the package manager where Julia packages are added and managed.

-   **Search mode**, activate by `ctrl+r`, as explained above.

-   **R mode**. Later, when discuss how R and Julia can work together with the RCall.jl package, there will an R mode available by typing **\$**. More later.

    ![](figs/REPLmodes.gif){width="500"}

Useful keys bindings ([here](https://docs.julialang.org/en/v1/stdlib/REPL/#Key-bindings) are many more):

-   Ctrl + C to interupt execution

-   Ctrl + L to clear the REPL

## The package manager: a first look

Similar, but more extreme than R, most things in Julia are available in packages. Packages are typically named with a .jl ending, for example the Distributions.jl package contain many statistical distributions. Julia packages are hosted on GitHub and managed by the Julia **General Registry**.

The package manager is most easily accessed by typing `]` to get into Pkg mode. The prompt changes to `(@v.11) pkg>` which means that you are in package mode in the default environment v.11 (if you are using Julia 1.11, more on environments later). Some useful commands in Pkg mode:

-   `status`, shows the packages installed in the currently active environment

-   `add` `PkgName` (installs the PkgName.jl package, for example Distributions.jl)

-   `rm` `PkgName` (removes the PkgName.jl package)

Here is comparison of package handling in R, Julia and Python.

+------------+---+----------------------------------------+---+-------------------------------+---+------------------------+
| Language   |   | Repository                             |   | Install packages              |   | Use packages           |
+------------+---+----------------------------------------+---+-------------------------------+---+------------------------+
| **R**      |   | CRAN (Comprehensive R Archive Network) |   | `install.packages("pkgname")` |   | `library(pkgname)`     |
+------------+---+----------------------------------------+---+-------------------------------+---+------------------------+
| **Julia**  |   | General registry (hosted on GitHub)    |   | `] add PkgName`               |   | `using` `PkgName`      |
+------------+---+----------------------------------------+---+-------------------------------+---+------------------------+
| **Python** |   | **PyPI** (Python Package Index)\       |   | `pip install pkgname`         |   | `import pkgname as pk` |
|            |   | or **Conda**                           |   |                               |   |                        |
+------------+---+----------------------------------------+---+-------------------------------+---+------------------------+

Once a package has been `add`ed it can be used from the Julian prompt (just `backspace` out from Pkg mode) with the using command: `using PkgName` . This loads the package in memory and its functions and other objects can now be used.

There are other ways to use a package, like `import`. The main difference is that

-    `using` exposes all exported function directly without needing to call then with the package name as prefix, e.g. `myfunc(3)`.

-    `import` does not expose exported function directly and requires a call to function to be prefixed with the package name, e.g. `PkgName.myfunc(3)`. This is closer to Python's namespace convention, but namespaces are less essential in Julia due to multiple dispatch and Julias clever handling of function (method) name collisions.

-   It is also possible to use only specific functions from a package: `using PkgName: myfunc, otherfunc`.

::: {.callout-important appearance="simple"}
## Exercise

-   `Add` the Distributions.jl package in the package manager. Type `status` after install to see that it indeed was added.

-   Use the Distributions.jl package by the `using` command from the Julian prompt.

-   Use the package to define a normal distribution object with mean 2 and and standard deviation 3. Go into help mode and search for `Normal` to see how this is done. Call the new object `dist`.

-   Generate 10 random draws from this normal distribution using the `rand` function on the normal distribution object `dist`.

-   Evaluate the pdf of this normal at `x=1` using the `pdf` function on the normal distribution object `dist`.
:::
