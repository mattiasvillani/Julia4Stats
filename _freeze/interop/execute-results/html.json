{
  "hash": "573f329263bdb71bafd4d62dce10d9b0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: \"Julia + R + Python = True\"\nauthor: \"Mattias Villani\"\neditor: visual\n---\n\n## Calling R from Julia code\n\n-   The [RCall.jl](https://juliainterop.github.io/RCall.jl/stable/) package makes it possible to call R from Julia.\n\n    -   An R package or function may be lacking in Julia\n\n    -   Benchmarking against methods in R packages.\n\n-   RCall.jl does:\n\n    -   **Sends R commands** to an R session in the background.\n\n    -   **Moves data** from Julia to R, and R back to Julia.\n\n    -   **Transforms data structures** in Julia to the \"right\" data structure in R. Dictionary -\\> list etc.\n\n    -   Enter **R mode** by typing `$` to get access to R console.\n\n-   To send a command to R, use `R\"julia_expression\"`\n\n::: {#8ef8f748 .cell execution_count=1}\n``` {.julia .cell-code}\nusing RCall         # Julia session must be set up, see RCall.jl docs\nR\"plot(rnorm(10))\";  # Evaluates in R\n```\n\n::: {.cell-output .cell-output-display}\n![](interop_files/figure-html/cell-2-output-1.png){}\n:::\n:::\n\n\n-   Variables in Julia can be interpolated in R code using the `$` -syntax\n\n::: {#09599ba0 .cell execution_count=2}\n``` {.julia .cell-code}\nn = 10\nR\"plot(rnorm($n))\";\n```\n\n::: {.cell-output .cell-output-display}\n![](interop_files/figure-html/cell-3-output-1.png){}\n:::\n:::\n\n\n-   Julia variables can be sent to R with @rput .\n\n-   R variables can be sent back to Julia with @rget.\n\n::: {#98ada5fa .cell execution_count=3}\n``` {.julia .cell-code}\n# Just some regression data to play with\nn = 100\np = 3\nX = randn(n,p)\nβ = [1, 2, 0.5]\nσ = 0.3\ny  = X*β + σ*randn(n)\n@rput y               # y now lives in the R session\n@rput X\nR\"modelFit <- lm(y ~ X)\"\nR\"betaHat <- modelFit$coef\"\nβhat = @rget betaHat  # Pull the R variable betaHat back to Julia\nβhat                  # lives in Julia now\n```\n\n::: {.cell-output .cell-output-display execution_count=48}\n```\n4-element Vector{Float64}:\n 0.043620495361893274\n 0.9772471884035804\n 2.014358371543607\n 0.592342891482621\n```\n:::\n:::\n\n\n-   For longer multiline code chunks, use the triple quotes:\n\n\n    ::: {#b89de7ab .cell execution_count=4}\n    ``` {.julia .cell-code}\n    z = 2\n    @rput z\n    R\"\"\"\n        f <- function(x, z) x + z\n        fvalue <- f(1, $z)\n    \"\"\"\n    out = @rget fvalue # Pull the R variable out back to Julia\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=49}\n    ```\n    3.0\n    ```\n    :::\n    :::\n    \n    \n-   Wrap R functions into Julia functions (works also for installed packages):\n\n\n    ::: {#f7ee4e71 .cell execution_count=5}\n    ``` {.julia .cell-code}\n    function ARMAacf(ar, ma; lagmax, pacf = false) \n        R\"\"\"\n            acf_theo = ARMAacf(ar = $ar, ma = $ma, lag.max = $lagmax, pacf = $pacf)\n        \"\"\"\n        @rget acf_theo\n    \treturn acf_theo\n    end\n    \n    ARMAacf([0.5, -0.2], [0.3]; lagmax = 5) # This is Julia function now\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=50}\n    ```\n    6-element Vector{Float64}:\n      1.0\n      0.5646766169154229\n      0.08233830845771144\n     -0.07176616915422887\n     -0.052350746268656725\n     -0.011822139303482589\n    ```\n    :::\n    :::\n    \n    \n## Calling Julia from R\n\n-   The `JuliaCall` package in R can be used to call Julia code from R.\n\n-   One time setup (install Julia first):\n\n```{r}\nlibrary(JuliaCall)\noptions(JULIA_HOME = \" ~/.juliaup/bin/julia\")     # Set path to Julia binary\njulia_setup()                                     # Setup Julia\njulia_command(\"a = sqrt(2.0)\")                    # Just testing the install\n```\n\nHere is a simple example:\n\n```{r}\njulia_install_package(\"LinearAlgebra\")            # Installs Julia package\njulia_library(\"LinearAlgebra\")                    # Loads Julia package\njulia_install_package(\"Distributions\")           \njulia_library(\"Distributions\")\n\njulia_source(\"code/poisloglik.jl\") # Julia code file, contains:\n#function poisreg_loglik(β, y, X)                        \n#   return sum(logpdf.(Poisson.(exp.(X*β)), y))\n#end\n\n# This is the R function definition, wrapping the Julia function\npoisreg_loglik <- function(beta_, y, X){\n  return(julia_call(\"poisreg_loglik\", beta_, y, X))\n}\nX = cbind(1, matrix(rnorm(100)))\nbeta_ = c(0.5,-0.5)\ny = rpois(100, lambda = exp(X %*% beta_))\npoisreg_loglik(beta_, y, X)\n```\n\n-   The R package <https://github.com/Non-Contradiction/autodiffr> uses JuliaCall to bring autodiff to R.\n\n## Using Python from Julia\n\n-   The [PyCall.jl](https://github.com/JuliaPy/PyCall.jl) package makes it possible to use Python code from Julia.\n\n-   At setup, you may need to tell PyCall.jl where your Python install is with `ENV[\"PYTHON\"] = \"~/anaconda3/bin/python\"` (this is my path) and then re-build PyCall from the package manager with `] build PyCall`\n\n-   Here is an example using the matplotlib library in Python for plotting\n\n\n    ::: {#c48b759f .cell execution_count=6}\n    ``` {.julia .cell-code}\n    using PyCall\n    x = range(0; stop=2*pi, length=1000)\n    y = sin.(3*x)\n    plt = pyimport(\"matplotlib.pyplot\")  # importing matplotlib as plt\n    plt.plot(x, y, color=\"red\", linewidth=2.0, linestyle=\"--\")\n    plt.show()\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    Figure(640x480)\n    ```\n    :::\n    :::\n    \n    \n-   Using Newton's method in the Python package SciPy for root finding\n\n\n    ::: {#24acb79a .cell execution_count=7}\n    ``` {.julia .cell-code}\n    so = pyimport(\"scipy.optimize\")\n    so.newton(x -> cos(x) - x, 1)\n    ```\n    \n    ::: {.cell-output .cell-output-display execution_count=52}\n    ```\n    0.7390851332151607\n    ```\n    :::\n    :::\n    \n    \n-   Using Python function in Julia:\n\n\n    ::: {#566275e6 .cell execution_count=8}\n    ``` {.julia .cell-code}\n    py\"\"\"\n    import numpy as np\n    \n    def my_sin(x):\n        print(\"hello from the Python side.\")\n        return np.sin(x)\n    \"\"\"\n    py\"my_sin\"(π/2)\n    ```\n    \n    ::: {.cell-output .cell-output-stdout}\n    ```\n    hello from the Python side.\n    ```\n    :::\n    \n    ::: {.cell-output .cell-output-display execution_count=53}\n    ```\n    1.0\n    ```\n    :::\n    :::\n    \n    \n-   Wrap a Python function in a Julia function\n\n::: {#4c670934 .cell execution_count=9}\n``` {.julia .cell-code}\nfunction my_sin(x)\n    return(py\"my_sin\"(x))\nend\nmy_sin(π/2) # This is a Julia function now\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nhello from the Python side.\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=54}\n```\n1.0\n```\n:::\n:::\n\n\n",
    "supporting": [
      "interop_files"
    ],
    "filters": [],
    "includes": {}
  }
}