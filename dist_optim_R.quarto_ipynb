{
  "cells": [
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "---\n",
        "title: \"Statistics with Julia\"\n",
        "author: \"Mattias Villani\"\n",
        "editor: visual\n",
        "---\n",
        "\n",
        "## Statistical distributions\n",
        "\n",
        "-   Julia has a fantastic unified system for statistical distributions, implemented mainly in the `Distributions.jl` package.\n",
        "\n",
        "-   Similar to Python, but different from R, **distributions are objects**.\n",
        "\n",
        "    -   `Normal(2,4)` is a $N(2,4^2)$ distribution object.\n",
        "\n",
        "    -   `Poisson(4)` is a $\\mathrm{Poisson}(4)$ distribution object."
      ],
      "id": "39803bec"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "using Distributions\n",
        "dist = Normal(1,3)"
      ],
      "id": "623776fc",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   We can call functions on distribution objects.\n",
        "\n",
        "-   Evaluate the **pdf** at a point $x=0$:"
      ],
      "id": "b52c2622"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "pdf(dist, 0)"
      ],
      "id": "65348d3a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Evaluate the cumulative distribution function (**cdf**)"
      ],
      "id": "b5bf4063"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "cdf(dist, 0) "
      ],
      "id": "00e77240",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Compute **quantiles**"
      ],
      "id": "85f60bfb"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "quantile(dist, [0.025, 0.5, 0.975])"
      ],
      "id": "1acf30f4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   Generate **random numbers**"
      ],
      "id": "d3397e26"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "rand(dist, 10) "
      ],
      "id": "9b5944b0",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   **Location-Scale families** are generated by addition and multiplication"
      ],
      "id": "8bf83432"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using Distributions\n",
        "1 + 2*TDist(3)"
      ],
      "id": "e44d0550",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "so one can easily define location-scale version"
      ],
      "id": "1e5e2b72"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "TDist(μ, σ, ν) = μ + σ*TDist(ν)\n",
        "dist = TDist(1, 2, 3)\n",
        "pdf(dist, 0)"
      ],
      "id": "e8138c5a",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   **Mixtures** can be built up from component distributions with `MixtureModel`"
      ],
      "id": "32650c61"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Mixture of two normals\n",
        "mixdist = MixtureModel([Normal(0, 1), Normal(5, 3)], [0.3, 0.7])\n",
        "pdf(mixdist, 1.0)\n",
        "quantile(mixdist, [0.025, 0.5, 0.975])"
      ],
      "id": "b2bb6ec4",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Any number of mixture components, also discrete.\n",
        "mixdist = MixtureModel([Poisson(1), NegativeBinomial(2,0.3), Geometric(0.4)], [0.1, 0.2, 0.7])\n",
        "pdf(mixdist, 4)"
      ],
      "id": "15ed808e",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   **Truncation**"
      ],
      "id": "66d54a8e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using Plots\n",
        "# Normal(0,1) truncated to [-1,1]\n",
        "dist = Truncated(Normal(0,1), -1, 1)\n",
        "xgrid = range(quantile(dist, 0.001), quantile(dist, 0.999), length = 500)\n",
        "plot(xgrid, pdf.(dist, xgrid), lw = 2)"
      ],
      "id": "811523aa",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Gamma truncated from below at 1\n",
        "dist = Truncated(Gamma(2,2), 1, Inf)\n",
        "xgrid = range(0, quantile(dist, 0.999), length = 500)\n",
        "plot(xgrid, pdf.(dist, xgrid), lw = 2)"
      ],
      "id": "c0d2ea81",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "-   **Censoring**"
      ],
      "id": "0ab5960d"
    },
    {
      "cell_type": "code",
      "metadata": {
        "md-indent": "    "
      },
      "source": [
        "# Censored Weibull\n",
        "cdfval = cdf(Weibull(2,2),3)\n",
        "println(\"cdf at x=3 of Weibull without truncation is $(cdfval)\")\n",
        "dist = censored(Weibull(2,2), upper = 3)\n",
        "println(\"cdf at x=3 of Weibull with truncation at x=3 is $(cdf(dist,3))\")\n",
        "println(\"pdf at x=3 of Weibull with truncation at x=3 is $(pdf(dist,3))\")"
      ],
      "id": "79d5e21b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can plot this by adding the extra point mass at the truncation point:"
      ],
      "id": "90b7ad7e"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "dist = censored(Weibull(2,2), upper = 3)\n",
        "plot(0:0.01:4, pdf.(dist, 0:0.01:4), lw = 2)\n",
        "\n",
        "# Point mass\n",
        "plot!([3, 3], [0, pdf(dist,3)], lw=3, color=:indianred, legend=false)\n",
        "scatter!([3], [pdf(dist,3)], m = :circle, mc = :indianred, ms = 8, \n",
        "  lc = :indianred, lw=2)"
      ],
      "id": "51042ab9",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "## Optimization and Autodiff\n",
        "\n",
        "The [Optim.jl](https://julianlsolvers.github.io/Optim.jl/stable/) package is the main package for numerical function optimization.\n",
        "\n",
        "As a simple example, consider finding the maximum likelihood estimate in Poisson regression with the BFGS optimizer.\n",
        "\n",
        "First, let us simulate some data from a Poisson regression model with an intercept and three covariates:"
      ],
      "id": "e1a91ef7"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "using Plots, Distributions, LinearAlgebra, Optim, ForwardDiff, Random, LaTeXStrings\n",
        "\n",
        "# Generate data from Poisson regression with β = [1,-1,1,-1]\n",
        "n = 500\n",
        "p = 4\n",
        "X = [ones(n,1) randn(n,p-1)]\n",
        "β = 0.5*[1,-1,1,-1]\n",
        "λ = exp.(X*β)\n",
        "y = rand.(Poisson.(λ));\n",
        "scatter(X[:,2], y, title = \"Scatter of y against the first covariate\", \n",
        "  xlabel = L\"x_1\", ylabel = L\"y\")"
      ],
      "id": "056d2158",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "To find the ML estimate we need to define the log-likelihood function:"
      ],
      "id": "2f710ae8"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Setting up the log likelihood function for Poisson regression\n",
        "function poisreg_loglik(β, y, X)                        \n",
        "    return sum(logpdf.(Poisson.(exp.(X*β)), y))\n",
        "end\n",
        "poisreg_loglik(β, y, X) # Test drive the function to see that it works."
      ],
      "id": "ef258f4b",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can now use the `maximize` function to find the ML estimate:\n",
        "\n",
        "-   the algorithm starts at the random initial value $\\beta_0$.\n",
        "\n",
        "-   the first argument in the function call is the log-likelihood function as an anonymous function of the single argument, the vector $\\beta$.\n",
        "\n",
        "-   the argument `autodiff = :forward` tells Julia to use automatic differentiation from the `ForwardDiff.jl` package to find the gradient vector, which is then used in the algorithm for finding the maximum.\n",
        "\n",
        "-   the output from the `maximize` function is an object with information about the optimization result. The field `maximizer` contains the $\\beta$ that maximizes the log-likelihood function."
      ],
      "id": "a8cb9dc5"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Find the MLE of β using Optim.jl\n",
        "β₀ = randn(p) # Initial guess for the optimization\n",
        "optres = maximize(β -> poisreg_loglik(β, y, X), β₀, BFGS(), \n",
        "  autodiff = :forward)\n",
        "βmle = Optim.maximizer(optres)"
      ],
      "id": "4fdce9ed",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "We can approximate the **standard errors of the ML estimator** using the Hessian of the log-likelihood. This matrix of second partial derivatives can also be obtained from automatic differentiation. The diagonal elements of the negative inverse Hessian approximates the variance of the individual $\\hat\\beta_j$ estimates:"
      ],
      "id": "40074e34"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "# Compute Hessian to get approximate standard errors\n",
        "H(β) = ForwardDiff.hessian(β -> poisreg_loglik(β, y, X), β)\n",
        "Ωᵦ = Symmetric(-inv(H(βmle))) # This approximates the covariance matrix of MLE\n",
        "diag(Ωᵦ) # Diagonal elements are the variances of the MLEs\n",
        "se = sqrt.(diag(Ωᵦ)) # Standard errors of the MLEs\n",
        "println(\"βmle: \\n\", round.(βmle, digits = 3))\n",
        "println(\"Standard errors: \\n\", round.(se, digits = 3))"
      ],
      "id": "6d80edb6",
      "execution_count": null,
      "outputs": []
    },
    {
      "cell_type": "markdown",
      "metadata": {},
      "source": [
        "Note how the `ForwardDiff.jl` package computes the Hessian matrix as function, which can then be rapidly evaluated for any $\\beta$ vector. Similarly, we can obtain the gradient as an explicit function and check that it is (numerically close to) the zero vector at the ML estimate:"
      ],
      "id": "a27fc4a3"
    },
    {
      "cell_type": "code",
      "metadata": {},
      "source": [
        "∂loglik(β) = ForwardDiff.gradient(β -> poisreg_loglik(β, y, X), β)\n",
        "∂loglik(β₀) # Gradient at the initial value, just because we can.\n",
        "∂loglik(βmle) # Gradient at the MLE, should be close to zero"
      ],
      "id": "c7f2bb3e",
      "execution_count": null,
      "outputs": []
    }
  ],
  "metadata": {
    "kernelspec": {
      "name": "julia-1.11",
      "language": "julia",
      "display_name": "Julia 1.11.6",
      "path": "/home/mv/.local/share/jupyter/kernels/julia-1.11"
    }
  },
  "nbformat": 4,
  "nbformat_minor": 5
}